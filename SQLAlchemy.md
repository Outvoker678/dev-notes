# SQLAlchemy ORM: Объектно-реляционное отображение в Python

---

### Введение в SQLAlchemy

SQLAlchemy — это мощная библиотека Python, предназначенная для работы с реляционными базами данных. Она предоставляет удобный и интуитивно понятный интерфейс, который упрощает взаимодействие с базами данных, делая код более читаемым и интегрированным в объектно-ориентированную парадигму Python.  
SQLAlchemy состоит из двух основных компонентов:

1. **Core** — низкоуровневый слой для прямых SQL-запросов и управления соединениями с базой данных.
2. **ORM (Object-Relational Mapping)** — высокоуровневый слой, позволяющий описывать таблицы базы данных в виде классов Python, что делает работу с данными более естественной для разработчиков.

> Данный конспект сосредоточен на ORM, так как он наиболее удобен для начинающих разработчиков, желающих быстро интегрировать базу данных в свои проекты.

---

### Установка SQLAlchemy

Для начала работы необходимо установить библиотеку SQLAlchemy. Это можно сделать с помощью пакетного менеджера pip:

```bash
pip install SQLAlchemy
```

Также требуется драйвер для работы с конкретной базой данных.  
Например, для SQLite, который встроен в Python, дополнительная установка не требуется.  
Для других баз данных, таких как PostgreSQL или MySQL, потребуется установить соответствующий драйвер (например, `psycopg2` для PostgreSQL).

---

### Основы работы с моделями данных

В SQLAlchemy ORM таблицы базы данных представляются в виде классов Python, а строки в таблицах — в виде объектов этих классов.  
Для создания модели данных используется базовый класс `DeclarativeBase`, который предоставляет необходимые инструменты для определения структуры таблицы.

### Пример создания модели данных

Рассмотрим процесс создания простой таблицы `users`, которая будет содержать колонки для идентификатора (`id`) и имени пользователя (`name`):

```python
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from sqlalchemy import String
from typing import Optional  # Класс который делает значение необязательным

# Определение базового класса для моделей
class Base(DeclarativeBase):
    pass

# Определение модели таблицы users
class User(Base):
    __tablename__ = "users"  # Имя таблицы в базе данных

    # Определение колонок таблицы
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[Optional[str]] = mapped_column(String(30))
```

### Разъяснение кода

1. **Импорт необходимых компонентов**:
    - `DeclarativeBase` — базовый класс, от которого наследуются все модели данных.
    - `Mapped` — типизация для указания типа данных колонки (например, `int` или `str`).
    - `mapped_column` — функция, определяющая свойства колонки, такие как тип данных или ограничения.
    - `String` — тип данных для строковых значений, позволяющий задать максимальную длину строки.

2. **Создание базового класса**:
    - Класс `Base` наследуется от `DeclarativeBase` и служит основой для всех моделей данных. Он необходим для корректной работы ORM и настройки метаданных.

3. **Создание модели `User`**:
    - Атрибут `__tablename__` задаёт имя таблицы в базе данных (в данном случае — `users`).
    - Колонка `id` определена как целое число (`Mapped[int]`) и является первичным ключом (`primary_key=True`), что обеспечивает уникальность каждой записи.
    - Колонка `name` определена как строка (`Mapped[Optional[str]]`) с максимальной длиной 30 символов (`String(30)`).
    - Мы оборачиваем тип `str` в `Optional[]`, чтобы указать, что значение может быть **необязательным** — то есть в базе данных оно может быть `NULL`, а в Python — `None`. Это полезно, если имя пользователя, например, не всегда заполняется сразу.

---

### Назначение первичного ключа

Первичный ключ (`primary_key=True`) гарантирует, что каждая запись в таблице имеет уникальный идентификатор.  
Это аналог нумерации строк в таблице Excel, где каждая строка имеет уникальный номер, который не повторяется.

---

### Связи между таблицами

Связи между таблицами в SQLAlchemy реализуются с помощью **внешнего ключа** (`ForeignKey`):

- **Внешний ключ** — это колонка в одной таблице, которая ссылается на колонку (обычно `id`) в другой таблице.
- В каждой строке этой колонки хранится идентификатор (`id`) связанной строки из другой таблицы.
- Это позволяет устанавливать связь между таблицами.

### Пример реализации связей

```python
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
from sqlalchemy import String, Integer
from sqlalchemy import ForeignKey  # Клас который добавляет функционал ключа

# Базовый класс для всех таблиц
class Base(DeclarativeBase):
    pass

# Таблица "users" (пользователи)
class User(Base):
    __tablename__ = "users"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(30))

# Таблица "orders" (заказы)
class Order(Base):
    __tablename__ = "orders"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    product: Mapped[str] = mapped_column(String(50))
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
```

**Пояснение к коду:**

- Колонка `user_id` в таблице `orders` создаётся с помощью `mapped_column(ForeignKey("users.id"))`.
- `ForeignKey("users.id")` указывает, что `user_id` ссылается на колонку `id` таблицы `users`.
- Если в `user_id` указать несуществующий `id` (например, 3, которого нет в таблице `users`), возникнет ошибка.

---

### Подключение к базе данных

### Объект `engine`

Для работы с базой данных в SQLAlchemy используется объект `engine`, который создаётся функцией `create_engine`.

- `engine` отвечает за взаимодействие с базой данных.
- Поддерживает различные драйверы (например, SQLite, PostgreSQL и др.).

### Пример подключения

```python
from sqlalchemy import create_engine

# Создание подключения к базе данных SQLite
engine = create_engine("sqlite:///my_database.db", echo=True)
```

**Параметры:**

- **Первый аргумент**: путь к базе данных (`sqlite:///my_database.db`).
- **Второй аргумент**: `echo=True` включает логирование всех операций с базой данных.

---

### Создание таблиц

Для создания наших таблиц в базе данных используется метод `metadata.create_all`:

```python
Base.metadata.create_all(engine)
```

**Пояснение:**

- `Base` — базовый класс, содержащий метаданные всех таблиц.
- `metadata.create_all(engine)` создаёт все таблицы, определённые в классах, в базе данных, указанной в `engine`.

### Работа с базой данных через сессии

После определения структуры базы данных и создания таблиц нам нужно взаимодействовать с ней: добавлять, извлекать или изменять данные. Для этого используется объект **сессии** (`Session`), который управляет операциями с базой данных.

#### Создание сессии

Сессия создаётся с помощью **фабрики sessions** (`sessionmaker`), которая связывается с объектом `engine`:

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# Создаём движок
engine = create_engine("sqlite:///example.db", echo=True)

# Создаём фабрику сессий
Session = sessionmaker(bind=engine)
```

- `sessionmaker(bind=engine)` создаёт фабрику, которая будет генерировать сессии для работы с базой данных.

- Каждая сессия — это временное "окно" для выполнения операций с базой данных.

#### Использование контекстного менеджера

Для работы с сессией рекомендуется использовать **контекстный менеджер** (`with`), который автоматически открывает и закрывает сессию, а также корректно обрабатывает ошибки:

```python
from sqlalchemy import create_engine, String
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, sessionmaker

# Базовый класс для моделей
class Base(DeclarativeBase):
    pass

# Модель таблицы users
class User(Base):
    __tablename__ = "users"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(30))
    email: Mapped[str] = mapped_column(String(100), unique=True)

# Создаём движок и таблицы
engine = create_engine("sqlite:///example.db", echo=True)
Base.metadata.create_all(engine)

# Создаём фабрику сессий
Session = sessionmaker(bind=engine)

# Добавляем пользователя
with Session() as session:
    new_user = User(name="Joe", email="joe@example.com")
    session.add(new_user)  # Добавляем пользователя в сессию
    session.commit()  # Сохраняем изменения в базе данных
```

**Пояснение к коду:**

1. **Создание объекта модели**: `new_user = User(name="Joe", email="joe@example.com")` создаёт экземпляр модели `User`, который представляет новую строку в таблице `users`.

2. **Добавление в сессию**: `session.add(new_user)` добавляет объект в сессию, но данные ещё не записаны в базу.

3. **Коммит изменений**: `session.commit()` записывает изменения в базу данных и закрывает транзакцию.

4. **Контекстный менеджер**: `with Session() as session` гарантирует, что сессия будет закрыта после выполнения операций, даже если произойдёт ошибка.

#### Обработка ошибок

Чтобы сделать код надёжнее, можно добавить обработку ошибок, например, для случаев, когда пользователь пытается добавить запись с уже существующим уникальным значением (например, `email`):

```python
from sqlalchemy.exc import IntegrityError

with Session() as session:
    try:
        new_user = User(name="Joe", email="joe@example.com")
        session.add(new_user)
        session.commit()
    except IntegrityError:
        session.rollback()  # Откатываем изменения при ошибке
        print("Ошибка: Пользователь с таким email уже существует!")
```

- `IntegrityError` возникает, если нарушается ограничение уникальности (например, `email` уже существует).

- `session.rollback()` отменяет все изменения в текущей сессии, чтобы база данных осталась в консистентном состоянии.

---

### Извлечение данных из базы

Для получения данных из базы данных используется функция `select`, которая позволяет формировать SQL-запросы в объектно-ориентированном стиле.

#### Пример получения данных

Допустим, мы хотим найти пользователя по имени:

```python
from sqlalchemy import select

# Создаём запрос
with Session() as session:
    statement = select(User).where(User.name == "Joe")
    result = session.scalars(statement).one()
    print(result.name, result.email)
```

**Пояснение к коду:**

1. **Формирование запроса**:

- `select(User)` указывает, что мы хотим получить данные из таблицы, связанной с моделью `User`.

- `.where(User.name == "Joe")` добавляет фильтр: выбираем только записи, где поле `name` равно `"Joe"`.

2. **Выполнение запроса**:

- `session.scalars(statement)` выполняет запрос и возвращает объекты модели `User`.

- `.one()` указывает, что мы ожидаем ровно одну запись. Если запись не найдена, возникнет исключение `NoResultFound`. Если найдено больше одной записи, возникнет `MultipleResultsFound`.

3. **Получение всех записей**:

Если нужно получить все записи, соответствующие условию, используйте `.all()` вместо `.one()`:

```python
with Session() as session:
    statement = select(User).where(User.name == "Joe")
    results = session.scalars(statement).all()
    for user in results:
        print(user.name, user.email)
```

- `.all()` возвращает список всех объектов `User`, соответствующих запросу.

#### Улучшение читаемости объектов

Чтобы объекты модели отображались красиво при выводе (например, через `print()`), можно добавить метод `__repr__` в класс модели:

```python
class User(Base):
    __tablename__ = "users"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(30))
    email: Mapped[str] = mapped_column(String(100), unique=True)
    
    def __repr__(self) -> str:
        return f"User(id={self.id}, name={self.name}, email={self.email})"
```

- Метод `__repr__` определяет, как объект будет представлен в виде строки.

- Теперь при вызове `print(user)` вы получите читаемый вывод, например: `User(id=1, name=Joe, email=joe@example.com)`.

**Почему это работает?**

SQLAlchemy автоматически создаёт атрибуты (`self.id`, `self.name`, `self.email`) для каждой колонки, определённой в модели. Эти атрибуты соответствуют данным из базы, и их можно использовать в коде, как обычные свойства объекта.

---

### Итог

SQLAlchemy ORM позволяет работать с базой данных так, будто вы работаете с обычными объектами Python. Основные шаги для работы с базой данных:

1. **Определите модель**: Создайте классы, описывающие таблицы, с помощью `DeclarativeBase` и `mapped_column`.

2. **Создайте движок**: Используйте `create_engine` для подключения к базе данных.

3. **Создайте таблицы**: Вызовите `Base.metadata.create_all(engine)` для создания таблиц.

4. **Работайте через сессии**: Используйте `sessionmaker` и контекстный менеджер для добавления, изменения или извлечения данных.

5. **Формируйте запросы**: Используйте `select` для выборки данных и методы вроде `.one()` или `.all()` для получения результатов.

Этот подход делает работу с базой данных интуитивной, безопасной и удобной для новичков. SQLAlchemy скрывает сложные SQL-запросы "под капотом", позволяя сосредоточиться на логике приложения.
